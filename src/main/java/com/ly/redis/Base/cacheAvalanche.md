### 缓存雪崩

---

##### 什么是缓存雪崩
- 缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
##### 有什么解决办法
* as
    * 事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
    * 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
    * 事后：利用 redis 持久化机制保存的数据尽快恢复缓存<br>
    ![github](https://github.com/Cynaith/Redis/blob/master/src/main/java/com/ly/redis/Base/cache.jpeg)
* 并发量不是特别多的时候，使用最多的解决方案是加锁排队。
    * 加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。<br>假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。<br>同样会导致用户等待超时，这是个治标不治本的方法！<br>
    `注意：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！`

* 还有一个解决办法解决方案是：给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。
    * 解释说明:
        * **缓存标记:** 记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存.
        * **缓存数据:** 它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。
* 比如做电商项目的时候，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。

